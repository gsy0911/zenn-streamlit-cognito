import collections
import json
import os
from datetime import datetime
from typing import List

import s3fs
from wafv2_ip_set import WafV2IpSet

fs = s3fs.S3FileSystem(anon=False)
IP_SETS_ARN = os.environ["IP_SETS_ARN"]
IP_SETS_NAME = os.environ["IP_SETS_NAME"]


class WafLogHttpRequest:
    def __init__(self, log: dict):
        self.args = log["args"]
        self.client_ip = log["clientIp"]
        self.country = log["country"]
        self.headers = log["headers"]
        self.http_method = log["httpMethod"]
        self.http_version = log["httpVersion"]
        self.request_id = log["requestId"]
        self.uri = log["uri"]

    def dumps(self):
        return {
            "args": self.args,
            "client_ip": self.client_ip,
            "country": self.country,
            "headers": self.headers,
            "http_method": self.http_method,
            "http_version": self.http_version,
            "uri": self.uri,
        }


class WafAlbLog:
    """
    See Also: https://docs.aws.amazon.com/waf/latest/developerguide/logging.html
    """

    def __init__(self, log: dict):
        self.action = log["action"]
        self.format_version = log["formatVersion"]
        self.http_request = WafLogHttpRequest(log=log["httpRequest"])
        self.timestamp = log["timestamp"]
        self.datetime = datetime.fromtimestamp(self.timestamp / 1000).strftime("%Y-%m-%d %H:%M:%S")
        self.is_attack_log = self.attack_check()
        self.http_source_id = log["httpSourceId"]
        self.http_source_name = log["httpSourceName"]
        self.non_terminating_matching_rules = log["nonTerminatingMatchingRules"]
        self.rate_based_rule_list = log["rateBasedRuleList"]
        self.request_headers_inserted = log["requestHeadersInserted"]
        self.response_code_sent = log["responseCodeSent"]
        self.rule_group_list = log["ruleGroupList"]
        self.terminating_rule_id = log["terminatingRuleId"]
        self.terminating_rule_match_details = log["terminatingRuleMatchDetails"]
        self.terminating_rule_type = log["terminatingRuleType"]
        self.web_acl_id = log["webaclId"]

    def dumps(self):
        return {
            "action": self.action,
            "version": self.format_version,
            "http_request": self.http_request.dumps(),
            "timestamp": self.timestamp,
        }

    def attack_check(self):
        is_php_attack = self._is_php_vulnerability_attack()
        is_node_attack = self._is_node_attack()
        is_microsoft_attack = self._is_microsoft_attack()
        is_kubernetes_attack = self._is_kubernetes_attack()
        is_oracle_attack = self._is_oracle_attack()
        root_access = self._root_access()
        return (
            is_php_attack
            or is_node_attack
            or is_microsoft_attack
            or is_kubernetes_attack
            or is_oracle_attack
            or root_access
        )

    def _is_php_vulnerability_attack(self) -> bool:
        """
        see: https://mat0401.info/blog/cyber-attack-server/
        see: https://rfs.jp/sb/wordpress/wp-lab/xmlrpc-php-ddos.html
        """
        if "/xmlrpc.php" in self.http_request.uri:
            return True
        if "/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php" in self.http_request.uri:
            return True
        if "/wp-login.php" in self.http_request.uri:
            return True
        if "/system_api.php" in self.http_request.uri:
            return True
        return False

    def _is_node_attack(self) -> bool:
        if "/.env" in self.http_request.uri:
            return True
        if "/wp-content/plugins/wp-file-manager/readme.txt" in self.http_request.uri:
            return True
        return False

    def _is_microsoft_attack(self) -> bool:
        if "/owa" in self.http_request.uri:
            return True
        return False

    def _is_kubernetes_attack(self) -> bool:
        if "/api/v1/pods" in self.http_request.uri:
            return True
        return False

    def _is_oracle_attack(self) -> bool:
        if "/_async/AsyncResponseService" in self.http_request.uri:
            return True
        return False

    def _root_access(self) -> bool:
        """
        `/`へのアクセスは通常ではできないため、プログラムからのアクセスの可能性が高いため
        Returns:
        """
        if "/" == self.http_request.uri:
            return True
        return False


def _get_target_date_log_list(target_date: str) -> List[WafAlbLog]:
    path = f"s3://aws-waf-logs-305119140072/raw/dt={target_date}/*"

    file_list = [f"s3://{f}" for f in fs.glob(path)]

    log_list = []
    for file_name in file_list:
        with fs.open(file_name, "r") as f:
            for line in f.readlines():
                log_list.append(WafAlbLog(json.loads(line)))
    return log_list


def handler(event, _):
    print(event)
    cloudwatch_time_format = "%Y-%m-%dT%H:%M:%SZ"
    # LambdaがCW Eventから実行されたdatetime
    invoke_datetime = datetime.strptime(event["time"], cloudwatch_time_format)

    # Logを取得する日付
    target_date = invoke_datetime.strftime("%Y-%m-%d")
    print(target_date)
    log_list = _get_target_date_log_list(target_date=target_date)
    attack_ip_candidates = []

    for log in log_list:
        # 不審な海外からのアクセスをブロック候補リストに追加
        if log.action == "ALLOW" and log.is_attack_log and log.http_request.country != "JP":
            attack_ip_candidates.append(log.http_request.client_ip)

    # 10回以上不審と判断されたIPアドレスは、ブロックリストに追加
    c = collections.Counter(attack_ip_candidates)
    print(c)
    block_candidate_ips_set = set([f"{k}/32" for k, v in c.items() if v > 10])
    print(block_candidate_ips_set)

    wafv2_ip_set = WafV2IpSet(ip_sets_name=IP_SETS_NAME, ip_sets_arn=IP_SETS_ARN)
    current_addresses = set(wafv2_ip_set.get_addresses())

    update_ip_set = set()
    update_ip_set.update(current_addresses)
    update_ip_set.update(block_candidate_ips_set)
    wafv2_ip_set.update_ip_set(list(update_ip_set))
    # 新規追加されたIPを表示
    print(f"newly added: {block_candidate_ips_set - current_addresses}")
    return {"status": "success", "updated_count": len(update_ip_set)}
